Q1. Sum of all multiples of first twin primes below n.

-(3 or 5)
int n;
cin>>in;
for(int i=1;i<n;i++){
   if(i%3==0 || i%5==0){
         sum += i;
   }
}

Time complexity: O(n)
Lets say it takes 14us for 1 iteration, for n=11 -> 10 iterations = 140us
1K = 14Kus
n = 14*n
1Ghz - 10^8 op/sec                       (n=10*18)
14*18/10^8 = 14*10^10 sec/(60*60*24*365)
           = 4700 yrs

- Constant complexity ans is much better
- Considering a combination of AP & GP, 
S3 = 3+6+9+.......+t3 = (n-1)/3 terms                -8us
   = 3(1+2+3+.....+t3)
   = 3*t3*(t3+1)/2
S5 = 5+10+15+.......+t5 = (n-1)/5 terms              -8us
   = 5(1+2+3+.....+t3)
   = 5*t5*(t5+1)/2
S3 = 15+30+45+.......+t15 = (n-1)/15 terms           -8us
   = 15(1+2+3+.....+t3)
   = 15*t15*(t15+1)/2
Sum=S3+S5-S15                                        -3us
-> 27us -> 27/10^8 sec -> 0.00000027sec

- to get more optimized code, we need DSA (thats what interviewers look for)
- projecteuler.net -> archieve -> 330 prob try practicing

Diff Complexities:
O(1)<O(logn)<O(root n)<O(n)<O(n logn).............<O(n^2)<O(n^2 logn)...<O(n^k)...<O(k^n)...<O(n!)

Q2. Chech whether a no is perfect or not?
                                          (28-1+2+4+7+14=28)
sum=0;
for(i=1;i<=n/2;i++){           -O(n)
    if(n%i==0){
         sum+=i;
       }
    if{sum>=n} ->yes

i<=root n           
sum += (i+n/i)

i*i<=n

q=sqrt(n)+1;
i<q

- this logic wont work for perfect squares
-> if(n%i==0&&i!=n/i)

Q3. Find the sum of prime nos below 2Million

- to check a prime, taking upto root n is enough!
- 65-> root 65 -> 2,3,4,5,6,7 -> 5 is a factor -> not a prime

int flag=0;
int q = (int)sqrt(n);
for(int i=2; i<=q; i++){

- prime no formula: except 2&3 -> 6k+/-1

if(n!=2 && (n&1)==0)
  flag=1;
else if(n!=3 && (n%3==0))
  flag=1;
else if(i=5;i<=q;i+=6)
     if(n%i==0 || (n%(i+2)==0){
           flag=1;
           break;
       }

sum=0;
for(n=1;n<=2000000;n++){        O(n)
    if(isprime(n))              O(root n)
-> O(n*rootn)

int f[101]={0}
int q=(int)sqrt(n);
for(int i=2; i<=q ;i++){                        O(root n)
      if(f[i]=0){
          for(int j=i*i; j<=n; j+=1){           O(root n)
               f[j]=1;
            }
         }
     }
sum=0;
for(int i=2;i<=n;i++){ if(f[i]==0) {
                          sum+=i;
---> worst case O(n)

- sieve of eratosthenes
- Explore segmented sieve
complexity:
n/2+n/3+n/4+............
n*(1/2+1/3+1/4+...........)
- <O(logn)

0 1 2 3 4 5 6 7 8 9 10
i=2; j=i*i=4,6,8,10
i=3; j=9
2 3 5 7

for(i=1;i<=10;i++)         10*c -> O(1)
   printf("*");

i<=n       -> O(n)

i<=n;i+=k   -> O(n)  - doesnt change the complexity
 
i<=sqrt(n)   -> O(root n)

i*=k      -> O(logn  basek)

for(i=n;i>=1;i/=k)   -> O(logn basek)

n arrays -> n*(n+1)/2 subarrays -> 2^n subsequence

k=1;
for(i=1;i),=n;i++){
    k=k*3;
     for(j=1;j<=k;j++){
           pf("*")
  }
}

i  j  k
1  3  3
2  9  9
3  27 27

sum=3,9,27
3(3^n - 1)/(3-1)= O(3^n)





AN------------------------------------------------------------------------

- Good hands on any programming langage: Java(85% companies) > C++ > .... > Python(only for problem solving and research purpose)
- Data Structures
- Algorithms

Quick sort: It is good but unstable so most of them do not prefer
Insertion > heap sort: insertion -> O(n), heap sort is best for priority queue & grid 
heap sort: inplace algorithm (at any step algorithm doesnt use any memory) 

array is more : heap
array is >1million: quick
array is already sort: insertion

Q. An array of n integer
   a) delete 2 minimum values
   b) add th absolute diff

sorting & deleting O(n^2)
best approach: heap sort

int minsetarray(ArrayList <Integer> a){
int n=a.size();

int result= pq.poll;

- running time  DS&A -> OOPS + CS(DBMS/OS/CN) - 12LPA
- LRU: Least Recently Used
- For >24LPA also learnTechstack: MERN,MEAN, React node, angular (Java techstack is best in industries) & System Design
- Linearization Technique
- Window Sliding Technique

HW: An array of n integers given, try to achieve maximum from the given array by performing the following operation any no of times:
    a) pick a[i], a[i+1] adjacent till they are signed 

i  i+1
9  10    =  -9  -10
-9 -10   =   9   10
-9 10    =   9  -10
9  -10   =  -9   10

a[5]={9,3,1,4,6}  23
    ={-9,3,-1,4,-6}   ...
 


       